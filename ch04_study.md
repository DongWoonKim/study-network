# ch_04 웹사이트의 동작 원리

### 웹사이트는 어떻게 생겼을까?

> <strong>웹사이트</strong>란 웹서버 애플리케이션이 공개하는 다양한 웹페이지의 집합이다. 웹사이트를 만들려면 웹서버에 애플리케이션을 설치하고, 공개할 웹페이지를 결정할 필요가 있다.

##### 웹사이트를 본다는 것

> 1. 웹브라우저에서 웹사이트 주소를 입력하거나 링크를 클릭하면, 웹서버 애플리케이션에 파일 전송 요청을 보낸다.
> 2. 웨서버 애플리케이션은 요청받은 파일을 응답으로 돌려보낸다.
> 3. 웹브라우저에서 수신한 파일을 표시하면서 웹사이트를 볼 수 있게 된다.
>
> 웹페이지 파일 전송에 이용하는 TCP/IP의 애플리케이션층 프로토콜은 HTTP이다. 애플리케이션층에서 인터넷층까지 프로토콜의 조합은 웹브라우저도 웹서버 애플리케이션도 모두 같다. 최하층인 네트워크 인터페이스층 프로토콜은 같은 것을 사용할 필요는 없다.

| 프로토콜  |         layer         |
| :-------: | :-------------------: |
|   HTTP    |    애플리케이션층     |
|    TCP    |     트랜스포트층      |
|    IP     |       인터넷층        |
| 이더넷 등 | 네트워크 인터페이스층 |





### 웹서버와 웹애플리케이션 서버의 차이 

###### 참조 : https://binux.tistory.com/32

##### static pages(정적 페이지)

> - html, css, javascript, image 파일과 같이 컴퓨터에 저장된 파일들을 의미한다.
> - 요청이 있을 때마다 웹 서버에서 요청에 맞는 페이지를 응답한다.
> - 웹 서버에서 제공한다.

##### dynamic pages(동적 페이지)

> - 요청에 맞게 동적으로 만들어진 컨텐츠를 뜻한다.
> - 데이터베이스, 서버 내의 로직 등을 활용해 만들어진 컨텐츠를 반환한다.
> - 웹 애플리케이션 서버에서 제공한다.



##### Web Server 웹 서버

> <strong>HTTP 요청을 받아 static contents 를 제공하는 서버, 프로그램</strong>
>
> HTTP프로토콜을 기반으로 하여 클라이언트의 요청을 서비스하는 기능을 담당 (ex Apache Server, Nginx, ..)
>
> 기능1 : 정적 컨텐츠 제공 : WAS를 거치지 않고, 바로 요청한 컨텐츠를 제공할 수 있다.
>
> 기능2 : 동적인 컨텐츠 제공을 위한 요청 전달 : 요청을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달한다.

##### WAS(Web Application Server) 웹 애플리케이션 서버

> <strong>다양한 서버 내의 알고리즘, 비즈니스 로직, DB 조회 등 클라이언트 요청에 따라 동적인 컨텐츠를 제공하는 서버, 프로그램</strong>
>
> HTTP프로토콜을 기반으로 하여 클라이언트의 요청에 따라 구현된 비즈니스 로직을 통해 동적으로 만들어진 컨텐츠를 반환 (ex Tomcat, JBoss, Jeus, ...)
>
> 기능 데이터베이스 접속 기능, 여러 개의 트랜잭션 관리 등 수행

##### Container 컨테이너

> 웹 서버가 보낸 JSP, PHP, ASP.net 등의 파일들을 실행하고 수행결과를 다시 웹 서버로 보내주는 역할을 한다.



정리를 해보자면 웹 애플리케이션 서버는 웹 서버에서 요청을 받고, 이를 웹 컨테이너로 보내 로직을 수행하고 그 결과를 다시 웹 서버로 보내 최종적으로 클라이언트에게 보내주는 것이다.



<img src="https://ifh.cc/g/5vsPTl.jpg" alt="l3-switch" style="zoom:50%;" />

<img src="https://ifh.cc/g/FXJbWj.jpg" alt="l3-switch" style="zoom:50%;" />



### WAS와 Web Server가 나누어져 있는 이유

##### 기능을 분리하여 서버 부하를 방지한다

> - WAS는 DB 조회, 다양한 로직 수행하느라 바쁘기 때문에 단순한 정적 컨텐츠는 Web Server에서 처리하는 것이 좋다.
> - 정적 컨텐츠 요청까지 WAS에서 수행하게 되면 부하가 커지게 되고, 동적 컨텐츠 처리가 지연됨에 따라 수행속도가 느려진다.

##### 물리적으로 분리하여 보안을 강화시킨다

> - SSL 대한 암복호화 처리에 Web Server를 사용

##### 여러 대의 WAS를 연결해 로드 밸런싱 용도로 사용할 수 있다.

> - Fail over, Fail back 처리에 유리하다.
> - 대용량 웹 어플리케이션의 경우 Web Server와 WAS를 분리하여 오류가 발생한 WAS를 사용하지 않고, 다른 WAS를 사용하게 만듦으로써 무중단 운영을 가능하게 한다.

##### 여러 언어의 웹 어플리케이션 서비스가 가능하다

> - 하나의 서버에서 PHP Application, Java Application를 함께 사용하는 등과 같이 여러 웹 어플리케이션의 활용이 가능해진다.
> - 톰캣은 Java언어만 해석이 가능하다.  PHP는 실행이 불가능하다. 하지만 Web Server로 아파치를 사용해 PHP를 사용할 수 있게 만들 수 있다.



결론적으로 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 Web Server와 WAS를 각기 사용한다.

### 웹사이트의 주소

##### URL의 의미

> 웹사이트를 보기 위해서는 어느 웹페이지 파일을 보고 싶은지 지정해야만 한다. 전송받고 싶은 웹페이지를 지정하는 것이 웹사이트의 주소이다.
>
> 웹사이트 주소는 주로 'http://'로 시작되는 문자열로, URL(Uniform Resource Locator)라고 불린다. 정식으로는 URI(Uniform Resource Identifier)이다.
>
> URL은 `http://www.xxxx.com/network/index.html ` 이런 모양을 가진다.
>
> 맨 앞의 http는 <strong>스킴</strong>이라고, 웹브라우저가 웹서버의 데이터에 접속하기 위한 프로토콜을 나타낸다. (ex https, ftp, ...)
>
> : 뒤에는 파일이 있는 장소를 나타내고, // 는 그 뒤로 이어지는 부분이 호스트명이다. 웹서버에 접속할 때는 호스트명에서 IP주소로 변환하는 DNS의 이름해석이 필요하다.
>
> 호스트명 뒤에는 포트 번호가 이어지지만, 대부분 생략한다. 생략한 경우에는 지정된 스킴에서 프로토콜의 웰노운 포트를 사용한다. 호스트명 뒷부분이 웹서버 어디에 목적으로 하는 파일이 있는지 나타내는 경로이다.
>
> `<스킴>://<호스트명>/<경로명>`



### 웹사이트의 파일을 요청한다

##### HTML 파일 전송

> 웹사이트를 구성하는 HTML 파일을 전송하기 위해 HTTP(Hyper Text Transfer Protocol)를 이용한다. HTTP를 그대로 해석하면, 하이퍼텍스트를 전송하는 프로토콜이다. 단, HTTP는 HTML 파일뿐만 아니라, 다양한 종류의 파일을 전송하는 범용적인 프로토콜로도 이용할 수 있다. 
>
> HTTP 파일 전송은 HTTP 리퀘스트(요청)와 HTTP 리스폰스(응답)를 주고받으면서 이루어진다. HTTP는 트랜스포트층의 프로토콜로서 TCP를 이용하므로, HTTP통신을 하기 전에 TCP커넥션을 맺는다.

##### HTTP 리퀘스트

> <strong>HTTP 리퀘스트</strong>는 리퀘스트 라인, 메시지 헤더, 엔티티 바디의 세 부분으로 나뉜다. 메시지 헤더와 엔티티 바디 사이에는 공백이 있다.
>
> <strong>리퀘스트라인</strong>은 HTTP 리퀘스트의 첫 번째 줄로, 웹서버에 대한 실제 처리 요청을 전달한다. 리퀘스트 라인은 다시 메서드, URI, 버전으로 구성된다. 가장 자주 사용되는 메서드는 GET메서드이다. 웹브라우저에서 URL을 입력하거나 링크를 클릭하거나 하면 GET 메서드의 HTTP리퀘스트를 웹서버 애플리케이션으로 보내게 된다.
>
> <strong>메시지 헤더</strong>는 요청 라인에 이어지는 여러 줄의 텍스트이다. 여기에는 웹브라우저의 종류와 버전, 대응하는 데이터의 형식 등의 정보를 기술한다.
>
> 메시지 헤더 다음은 공백 라인으로 구분하고, 그 뒤로 <strong>엔티티 바디</strong>가 이어진다.
>
> <strong>엔티티 바디</strong>는 POST 메서드로 웹브라우저에서 데이터를 보낼 때 사용된다.

<img src="https://ifh.cc/g/jSzXR8.jpg" alt="l3-switch" style="zoom:50%;" />

| 메서드  |                  의미                  |
| :-----: | :------------------------------------: |
|   GET   |    URI로 지정한 데이터를 가져온다.     |
|  HEAD   | URI로 지정한 데이터의 헤더만 가져온다. |
|  POST   |        서버에 데이터를 보낸다.         |
|   PUT   |         서버에 파일을 보낸다.          |
| DELETE  |   서버의 파일을 삭제하도록 요청한다.   |
| CONNECT |     프록시 서버를 경유해 통신한다.     |



### 웹사이트의 파일을 전송한다

##### 응답으로 돌아오는 HTTP 리스폰스

> HTTP 리퀘스트에 대한 응답으로 HTTP 리스폰스를 반환한다. HTTP리스폰스는 리스폰스 라인, 메시지 헤더, 엔티티 바디로 구성된다.
>
> 리스폰스 라인은 다시 버전, 상태 코드, 설명문으로 나뉜다. 
>
> <strong>버전</strong>은 HTTP의 버전을 나타내며, 현재 주요 버전은 1.0이나 1.1이다. 
>
> <strong>상태 코드</strong>는 리퀘스트에 대한 웹서버 애플리케이션의 처리 결과를 나타내는 3자리로 된 숫자이다.
>
> <strong>설명문</strong>이란 상태 코드의 의미를 간단히 보여주는 텍스트이다.
>
> <strong>메시지 헤더</strong>는 웹서버 애플리케이션이 더 자세한 정보를 웹브라우저에 전달하기 위해 이용한다.
>
> 그 뒤로 공백 라인이 있고, 공백 라인 뒤에 엔티티 바디가 이어진다. <strong>엔티티 바디</strong>에는 웹브라우저로 돌려보낼 데이터가 들어간다. 웹브라우저에 돌려 보내는 데이터는 주로 HTML이다.

<img src="https://ifh.cc/g/V7iwJj.jpg" alt="l3-switch" style="zoom:50%;" />

##### 

| 상태 코드 값 |                             의미                             |
| :----------: | :----------------------------------------------------------: |
|     1xx      |              정보, 추가 정보가 있음을 전달한다.              |
|     2xx      |           성공, 서버가 요청을 처리했음을 전달한다.           |
|     3xx      |     리다이렉트, 다른 URI로 다시 리퀘스트하도록 요청한다.     |
|     4xx      | 클라이언트 에러. 요청에 문제가 있어 처리할 수 없음을 전달한다. |
|     5xx      | 서버 에러, 서버 쪽에 문제가 있어 처리할 수 없음을 전달한다.  |



### 웹사이트 접속 기록을 기억해 둔다

##### 웹페이지의 내용을 커스터마이징하고 싶다

> 상황에 따라 웹페이지의 내용을 커스터마이징하고 싶을 때에는 HTTP 쿠키(Cookie)를 이용한다.

##### 특정 정보를 기억해 두는 HTTP 쿠키

> <strong>HTTP 쿠키</strong>는 웹서버 애플리케이션이 웹브라우저에 특정 정보를 저장해 두는 기술이다.
>
> 웹서버 애플리케이션은 웹브라우저의 요청에 대한 HTTP 리스폰스에 쿠키를 포함하여 보낸다.(쿠키 정보는 HTTP 헤더에 포함된다.) 웹브라우저가 쿠키를 받을 수 있게 설정되어 있으면, 수신한 쿠키를 저장한다. 그 뒤로 같은 웹사이트에 접속할 때는 HTTP 리퀘스트에 쿠키도 함께 포함된다.
>
> 쿠키를 이용함으로써, 웹서버는 사용자의 로그인 정보나 사이트 내 웹페이지 열람 이력을 관리할 수 있다. 접속한 사용자에 맞게 웹페이지 내용을 개인화할 수도 있다.



### 웹사이트 접속을 대행한다

##### 웹 접속을 대신하는 서버

> 웹페이지를 열람할 때 웹브라우저와 웹서버 애플리케이션은 서로 통신한다. 그 사이에 <strong>프록시 서버</strong>를 거치는 경우가 있다. 프록시 서버란 웹사이트 접속을 대행하는 서버이다.
>
> 서버를 프록시 서버로 동작시키려면, 서버에서 프록시 서버 애플리케이션을 실행해야 한다. 또 이 프록시 서버를 이용하기 위해서는 웹브라우저에서 프록시 서버 설정을할 필요가 있다.
>
> 프록시 서버를 경유하는 웹 접속은 아래와 같이 진행된다.
>
> 1. 클라이언트 PC의 웹브라우저에서 URL을 입력하면, 프록시 서버로 HTTP 리퀘스트를 보낸다.
> 2. 프록시 서버에서 URL로 지정된 웹서버에 HTTP 리퀘스트를 보낸다.
> 3. 웹서버에서 프록시 서버로 HTTP 리스폰스를 보낸다.
> 4. 프록시 서버에서 클라이언트 PC의 웹브라우저로 HTTP 리스폰스를 보낸다.



###  더 알아보기 : 프록시 서버

**프록시 서버**([영어](https://ko.wikipedia.org/wiki/영어): proxy server 프록시 서버[[*](https://ko.wikipedia.org/wiki/위키백과:영어의_한글_표기)])는 [클라이언트](https://ko.wikipedia.org/wiki/클라이언트)가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 [컴퓨터 시스템](https://ko.wikipedia.org/wiki/컴퓨터_시스템)이나 [응용 프로그램](https://ko.wikipedia.org/wiki/응용_소프트웨어)을 가리킨다. [서버](https://ko.wikipedia.org/wiki/서버)와 클라이언트 사이에 중계기로서 대리로 통신을 수행하는 것을 가리켜 '프록시', 그 중계 기능을 하는 것을 프록시 서버라고 부른다.

프록시 서버 중 일부는 프록시 서버에 요청된 내용들을 [캐시](https://ko.wikipedia.org/wiki/캐시)를 이용하여 저장해 둔다. 이렇게 캐시를 해 두고 난 후에, 캐시 안에 있는 정보를 요구하는 요청에 대해서는 원격 서버에 접속하여 데이터를 가져올 필요가 없게 됨으로써 전송 시간을 절약할 수 있게 됨과 동시에 불필요하게 외부와의 연결을 하지 않아도 된다는 장점을 갖게 된다. 또한 외부와의 트래픽을 줄이게 됨으로써 네트워크 병목 현상을 방지하는 효과도 얻을 수 있게 된다.

## Proxy 서버 종류

프록시 서버가 서비스 서버에 작업하는 위치와 네트워크 구성에 따라서 크게 Forward Proxy/Reverse Proxy 로 구분된다.

### Forward Proxy (포워드 프록시)

일반적인 프록시 서버를 말하며, 클라이언트와 웹 서버의 중계역할로 클라이언트가 요청 시 Proxy서버는 해당 요청을 웹 서버로 중계해 자원을 가져오는 개념이다.

프록시 서버는 클라이언트가 요청하기 전까지 웹 서버의 주소를 알 수 없다.

### Reverse Proxy (리버스 프록시)

클라이언트와 내부망(Private Netowrk) 서버 사이에(앞에) 위치하여 제어역할을 한다. 그래서 클라이언트가 요청을 하면 프록시 서버가 내부망 서버에 요청 후 응답 받은 자원을 클라이언트에게 전달해주는 개념이다.

리버스 프록시 서버는 실제 서버들에 대한 주소를 매핑하고 있어야 한다. 그리고 내부망에 서버에 대해 보안적으로나 로드밸런싱을 위해 사용되기도 한다.

###### 참조 : https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%EC%84%9C%EB%B2%84#%EB%A6%AC%EB%B2%84%EC%8A%A4_%ED%94%84%EB%A1%9D%EC%8B%9C

###### 참조 : https://lygggg.github.io/blog/proxy/



### 직원이 보는 웹사이트를 확인한다

##### 관리자 입자에서 보는 프록시 서버의 목적

> 1. 클라이언트의 웹브라우저에서 접속하는 웹사이트를 확인한다.
>    - 관리자가 프록시 서버를 이용하는 목적 중 하나는 클라이언트 PC의 웹브라우저에서 어떤 웹사이트에 접속하는 지를 확인하는 것이다. 직원이 업무에 관계 없는 웹사이트에 접속하는지 확인 가능하다.
> 2. 부정한 웹사이트에 접속할 수 없게 한다.
>    - 프록시 서버를 이용하면 부정한 웹사이트에 접속할 수 없게 제한할 수 있다.
>    - 웹사이트에 대한 접속 제한을 <strong>URL 필터링</strong> 또는 <strong>웹 필터링</strong>이라고 부른다.



### 웹브라우저는 웹서핑만 하는 게 아니다

##### 웹브라우저만 있으면 된다

> 오늘날 웹브라우저는 단순히 웹사이트만 보는 애플리케이션이 아니다. 애플리케이션의 유저 인터페이스로도 널리 이용되고 있다. 웹브라우저를 유저 인터페이스로 이용하는 애플리케이션을 <strong>웹 애플리케이션</strong>이라고 한다.
>
> 웹 애플리케이션은 웹브라우저를 유저 인터페이스로 사용하므로, 클라이언트 PC용 전용 애플리케이션을 개발해 설치해 둘 필요가 없다. 웹 서버 쪽에서 화면 레이아웃 구성이나 입력 파라미터 확인 및 처리를 어떻게 할지 결정하기만 하면 된다.
>
> 처리 자체는 웹서버가 아니라 별도 애플리케이션 서버를 사용하기도 한다. 애플리케이션 서버는 다시 데이터베이스 서버와 연계하는 경우도 있다.

### 웹사이트를 볼 때의 준비

##### 이용하는 프로토콜

<img src="https://ifh.cc/g/YSw0Ur.jpg" alt="l3-switch" style="zoom:60%;" />



### 웹사이트를 보는 흐름

##### 웹사이트를 볼 때의 동작

> 웹사이트를 보기 위해서 <strong>HTTP 리퀘스트</strong>와 <strong>HTTP 리스폰스</strong>를 주고받지만, 그 전에 <strong>DNS의 이름해석</strong>과 <strong>ARP의 주소해석 기능</strong>도 동작한다. 그리고 TCP로 커넥션도 맺는다. 
>
> HTTP 리퀘스트를 받은 웹서버 애플리케이션은 요청된 웹페이지의 파일을 HTTP리스폰스로 반환한다. TCP에서 복수로 분할된 웹페이지의 파일을 조립하여 웹브라우저에 그 내용을 표시하면, 사용자는 웹사이트를 볼 수 있게 된다.
>
> 1. 웹브라우저의 URL을 입력
> 2. 웹서버의 IP 주소를 해석
> 3. TCP 커넥션 확립
> 4. HTTP리퀘스트 전송과 HTTP 리스폰스 전송



















